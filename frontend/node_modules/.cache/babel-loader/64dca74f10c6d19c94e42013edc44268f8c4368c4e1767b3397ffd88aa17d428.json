{"ast":null,"code":"export const parseTabDelimited = text => {\n  if (!text || !text.trim()) return [];\n  const lines = text.trim().split('\\n');\n  const rows = lines.map(line => line.split('\\t'));\n  return rows;\n};\nexport const detectColumns = (rows, targetColumns) => {\n  if (!rows || rows.length === 0) return {};\n  const headerRow = rows[0];\n  const mapping = {};\n  targetColumns.forEach(target => {\n    const normalized = target.toLowerCase().replace(/[\\s\\/\\-_]/g, '');\n    const columnIndex = headerRow.findIndex(header => {\n      const normalizedHeader = header.toLowerCase().replace(/[\\s\\/\\-_]/g, '');\n      return normalizedHeader.includes(normalized) || normalized.includes(normalizedHeader);\n    });\n    if (columnIndex !== -1) {\n      mapping[target] = columnIndex;\n    }\n  });\n  return mapping;\n};\nexport const mapRowsToObjects = (rows, mapping, startRow = 1) => {\n  if (!rows || rows.length <= startRow) return [];\n  return rows.slice(startRow).map((row, idx) => {\n    const obj = {};\n    Object.entries(mapping).forEach(([key, index]) => {\n      obj[key] = row[index] || '';\n    });\n    obj._rowIndex = idx;\n    return obj;\n  }).filter(obj => {\n    // Filter out empty rows\n    const values = Object.values(obj).filter(v => v && v !== obj._rowIndex);\n    return values.length > 0;\n  });\n};\nexport const parseNumericValue = value => {\n  if (typeof value === 'number') return value;\n  if (!value) return 0;\n  let str = String(value).trim();\n\n  // Remove R$, espaços e outros caracteres não numéricos (exceto . , -)\n  str = str.replace(/[^\\d,.-]/g, '');\n\n  // Detectar formato: se tem vírgula E ponto, determinar qual é decimal\n  const hasComma = str.includes(',');\n  const hasDot = str.includes('.');\n  if (hasComma && hasDot) {\n    // Ambos presentes: o último é o decimal\n    const lastComma = str.lastIndexOf(',');\n    const lastDot = str.lastIndexOf('.');\n    if (lastComma > lastDot) {\n      // Formato brasileiro: 1.500,50 -> remove pontos, troca vírgula por ponto\n      str = str.replace(/\\./g, '').replace(',', '.');\n    } else {\n      // Formato americano: 1,500.50 -> remove vírgulas\n      str = str.replace(/,/g, '');\n    }\n  } else if (hasComma) {\n    // Só vírgula: pode ser 1,5 (decimal) ou 1500,00 (milhares + decimal)\n    const parts = str.split(',');\n    if (parts[0].length > 3 || parts[1] && parts[1].length !== 2) {\n      // Provavelmente formato brasileiro com milhares: 1500,00 -> apenas troca vírgula\n      str = str.replace(',', '.');\n    } else {\n      // Decimal simples: 1,5 -> troca vírgula\n      str = str.replace(',', '.');\n    }\n  } else if (hasDot) {\n    // Só ponto: pode ser 1.5 (decimal) ou 1.500 (milhares)\n    const parts = str.split('.');\n    if (parts.length === 2 && parts[1].length === 3 && parts[0].length <= 3) {\n      // Formato brasileiro de milhares: 1.500 -> remove o ponto\n      str = str.replace('.', '');\n    }\n    // Senão mantém o ponto como decimal: 1.5\n  }\n  const parsed = parseFloat(str);\n  return isNaN(parsed) ? 0 : parsed;\n};\nexport const formatCurrency = value => {\n  return new Intl.NumberFormat('pt-BR', {\n    style: 'currency',\n    currency: 'BRL'\n  }).format(value || 0);\n};\nexport const formatPercentage = value => {\n  return new Intl.NumberFormat('pt-BR', {\n    style: 'percent',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  }).format((value || 0) / 100);\n};","map":{"version":3,"names":["parseTabDelimited","text","trim","lines","split","rows","map","line","detectColumns","targetColumns","length","headerRow","mapping","forEach","target","normalized","toLowerCase","replace","columnIndex","findIndex","header","normalizedHeader","includes","mapRowsToObjects","startRow","slice","row","idx","obj","Object","entries","key","index","_rowIndex","filter","values","v","parseNumericValue","value","str","String","hasComma","hasDot","lastComma","lastIndexOf","lastDot","parts","parsed","parseFloat","isNaN","formatCurrency","Intl","NumberFormat","style","currency","format","formatPercentage","minimumFractionDigits","maximumFractionDigits"],"sources":["/app/frontend/src/utils/dataParser.js"],"sourcesContent":["export const parseTabDelimited = (text) => {\n  if (!text || !text.trim()) return [];\n  \n  const lines = text.trim().split('\\n');\n  const rows = lines.map(line => line.split('\\t'));\n  return rows;\n};\n\nexport const detectColumns = (rows, targetColumns) => {\n  if (!rows || rows.length === 0) return {};\n  \n  const headerRow = rows[0];\n  const mapping = {};\n  \n  targetColumns.forEach(target => {\n    const normalized = target.toLowerCase().replace(/[\\s\\/\\-_]/g, '');\n    \n    const columnIndex = headerRow.findIndex(header => {\n      const normalizedHeader = header.toLowerCase().replace(/[\\s\\/\\-_]/g, '');\n      return normalizedHeader.includes(normalized) || normalized.includes(normalizedHeader);\n    });\n    \n    if (columnIndex !== -1) {\n      mapping[target] = columnIndex;\n    }\n  });\n  \n  return mapping;\n};\n\nexport const mapRowsToObjects = (rows, mapping, startRow = 1) => {\n  if (!rows || rows.length <= startRow) return [];\n  \n  return rows.slice(startRow).map((row, idx) => {\n    const obj = {};\n    Object.entries(mapping).forEach(([key, index]) => {\n      obj[key] = row[index] || '';\n    });\n    obj._rowIndex = idx;\n    return obj;\n  }).filter(obj => {\n    // Filter out empty rows\n    const values = Object.values(obj).filter(v => v && v !== obj._rowIndex);\n    return values.length > 0;\n  });\n};\n\nexport const parseNumericValue = (value) => {\n  if (typeof value === 'number') return value;\n  if (!value) return 0;\n  \n  let str = String(value).trim();\n  \n  // Remove R$, espaços e outros caracteres não numéricos (exceto . , -)\n  str = str.replace(/[^\\d,.-]/g, '');\n  \n  // Detectar formato: se tem vírgula E ponto, determinar qual é decimal\n  const hasComma = str.includes(',');\n  const hasDot = str.includes('.');\n  \n  if (hasComma && hasDot) {\n    // Ambos presentes: o último é o decimal\n    const lastComma = str.lastIndexOf(',');\n    const lastDot = str.lastIndexOf('.');\n    \n    if (lastComma > lastDot) {\n      // Formato brasileiro: 1.500,50 -> remove pontos, troca vírgula por ponto\n      str = str.replace(/\\./g, '').replace(',', '.');\n    } else {\n      // Formato americano: 1,500.50 -> remove vírgulas\n      str = str.replace(/,/g, '');\n    }\n  } else if (hasComma) {\n    // Só vírgula: pode ser 1,5 (decimal) ou 1500,00 (milhares + decimal)\n    const parts = str.split(',');\n    if (parts[0].length > 3 || (parts[1] && parts[1].length !== 2)) {\n      // Provavelmente formato brasileiro com milhares: 1500,00 -> apenas troca vírgula\n      str = str.replace(',', '.');\n    } else {\n      // Decimal simples: 1,5 -> troca vírgula\n      str = str.replace(',', '.');\n    }\n  } else if (hasDot) {\n    // Só ponto: pode ser 1.5 (decimal) ou 1.500 (milhares)\n    const parts = str.split('.');\n    if (parts.length === 2 && parts[1].length === 3 && parts[0].length <= 3) {\n      // Formato brasileiro de milhares: 1.500 -> remove o ponto\n      str = str.replace('.', '');\n    }\n    // Senão mantém o ponto como decimal: 1.5\n  }\n  \n  const parsed = parseFloat(str);\n  return isNaN(parsed) ? 0 : parsed;\n};\n\nexport const formatCurrency = (value) => {\n  return new Intl.NumberFormat('pt-BR', {\n    style: 'currency',\n    currency: 'BRL'\n  }).format(value || 0);\n};\n\nexport const formatPercentage = (value) => {\n  return new Intl.NumberFormat('pt-BR', {\n    style: 'percent',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  }).format((value || 0) / 100);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}